<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Niek Den Teuling" />


<title>Conducting a simulation study</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Conducting a simulation study</h1>
<h4 class="author">Niek Den Teuling</h4>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#data-generation" id="toc-data-generation">Data
generation</a></li>
<li><a href="#data-settings" id="toc-data-settings">Data
settings</a></li>
<li><a href="#method-settings" id="toc-method-settings">Method
settings</a>
<ul>
<li><a href="#specifying-the-gckm-method" id="toc-specifying-the-gckm-method">Specifying the GCKM method</a></li>
</ul></li>
<li><a href="#evaluating-the-settings" id="toc-evaluating-the-settings">Evaluating the settings</a></li>
<li><a href="#analyzing-the-results" id="toc-analyzing-the-results">Analyzing the results</a>
<ul>
<li><a href="#recovery-of-the-number-of-clusters" id="toc-recovery-of-the-number-of-clusters">Recovery of the number of
clusters</a></li>
<li><a href="#trajectory-assignment-agreement" id="toc-trajectory-assignment-agreement">Trajectory assignment
agreement</a></li>
<li><a href="#residual-error" id="toc-residual-error">Residual
error</a></li>
</ul></li>
</ul>
</div>

<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>In this vignette we demonstrate how to conduct a simulation study
with minimal coding. We show how to do a structural evaluation of
methods for clustering longitudinal data, for different specifications,
and across various (synthetic) data scenarios.</p>
<p>A typical workflow in a simulation study involves:</p>
<ol style="list-style-type: decimal">
<li><a href="#data-settings">Data settings</a></li>
<li><a href="#method-settings">Method settings</a></li>
<li><a href="#evaluating-the-settings">Evaluating the settings</a></li>
<li><a href="#analyzing-the-results">Analyzing the results</a></li>
</ol>
<p>There are many packages available in <code>R</code> which facilitate
such a workflow. In this vignette, we use the <a href="https://cran.r-project.org/package=simTool">simTool</a>
package.</p>
<p>Due to the relatively large number of models fitted, we will disable
all model outputs:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(latrend)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">options</span>(<span class="at">latrend.verbose =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
</div>
<div id="data-generation" class="section level1">
<h1>Data generation</h1>
<p>Using synthetic data allows us to investigate to performance of the
methods under specific conditions of interest (e.g., sensitivity to
noise, within-cluster variability, and cluster separation).</p>
<p>For demonstration purposes, we define a trivial dataset comprising
two distinct groups with group trajectories represented by a line (i.e.,
intercept and slope). A trajectory <span class="math inline">\(\textbf{y}_i\)</span> belonging to group <span class="math inline">\(k\)</span> is described by <span class="math inline">\(y_{ij} = \beta_{0k} + \beta_{1k} t_{j} + z_{0i} +
e_{ij}\)</span>. Here, <span class="math inline">\(\beta_{0k}\)</span>
and <span class="math inline">\(\beta_{1k}\)</span> are the intercept
and slope for group <span class="math inline">\(k\)</span>,
respectively. Furthermore, <span class="math inline">\(z_i\)</span>
denotes the trajectory-specific random intercept, i.e., its deviation
from the group trajectory. Lastly, <span class="math inline">\(e_{ij}\)</span> represents independent random
noise with <span class="math inline">\(e_{ij} \sim N(0,
\sigma^2)\)</span>.</p>
<p>We can generate data according to this model using a utility function
named <code>generateLongData()</code> that is included in the package.
This function generates datasets based on a mixture of linear mixed
models. We create a wrapper around this function in order to adapt the
function to our needs. Most importantly, we code the shape and
coefficients of the group trajectories as fixed, setting <span class="math inline">\((\beta_{0A},\beta_{1A}) = (0, 0)\)</span> for
group A (40%) and <span class="math inline">\((\beta_{0B},\beta_{1B}) =
(1, -1)\)</span> for group B (60%). Other data settings (e.g., the
magnitude of perturbation) are passed via <code>...</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>dataGen <span class="ot">&lt;-</span> <span class="cf">function</span>(numTraj, ..., data.seed) {</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  latrend<span class="sc">::</span><span class="fu">generateLongData</span>(</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>    <span class="at">sizes =</span> <span class="fu">c</span>(<span class="fu">floor</span>(numTraj <span class="sc">*</span> .<span class="dv">4</span>), <span class="fu">ceiling</span>(numTraj <span class="sc">*</span> .<span class="dv">6</span>)),</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>    <span class="at">fixed =</span> Y <span class="sc">~</span> <span class="dv">0</span>,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>    <span class="at">cluster =</span> <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> Time,</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>    <span class="at">random =</span> <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>    <span class="at">id =</span> <span class="st">&quot;Traj&quot;</span>,</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    <span class="at">clusterCoefs =</span> <span class="fu">cbind</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="fu">c</span>(<span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>)),</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    <span class="at">seed =</span> data.seed,</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    ...</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>  )</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>}</span></code></pre></div>
<p>Because the <em>simTool</em> package does not appear to support
overlapping names between data and method functions, we needed to rename
the <code>seed</code> argument of our underlying data generating
function.</p>
<p>Note that the <code>generateLongData</code> is included in the
<em>latrend</em> package primarily for demonstration purposes. For
generating data in a more flexible way, consider using the <a href="https://cran.r-project.org/package=simstudy">simstudy</a>
package.</p>
<p>Now that we have defined a data generating function, we set the
default trajectory id and time column names, so we do not have to
specify this in any future calls.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">options</span>(<span class="at">latrend.id =</span> <span class="st">&quot;Traj&quot;</span>, <span class="at">latrend.time =</span> <span class="st">&quot;Time&quot;</span>)</span></code></pre></div>
<p>It’s a good idea to inspect the data we are generating.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>exampleData <span class="ot">&lt;-</span> <span class="fu">dataGen</span>(<span class="at">numTraj =</span> <span class="dv">200</span>, <span class="at">randomScale =</span> .<span class="dv">1</span>, <span class="at">data.seed =</span> <span class="dv">1</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a><span class="fu">plotTrajectories</span>(exampleData, <span class="at">response =</span> <span class="st">&quot;Y&quot;</span>)</span></code></pre></div>
<p><img role="img" src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="data-settings" class="section level1">
<h1>Data settings</h1>
<p>We now specify the data settings of interest. In this example, we
evaluate the methods on datasets with varying sample size (50 and 250
trajectories) and random intercept scale (small and large random
intercept). Moreover, we evaluate methods repeatedly under these
settings by specifying different values for <code>data.seed</code>,
generating a slightly different dataset for each seed.</p>
<p>As we intend to evaluate the methods on each combination of data
settings, we need to generate a table of all permutations. This can be
done using the <code>expand.grid()</code> function, or using
<code>expand_tibble()</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>dataGrid <span class="ot">&lt;-</span> simTool<span class="sc">::</span><span class="fu">expand_tibble</span>(</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="at">fun =</span> <span class="st">&quot;dataGen&quot;</span>,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="at">numTraj =</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">250</span>),</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="at">randomScales =</span> <span class="fu">c</span>(.<span class="dv">1</span>, .<span class="dv">5</span>),</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="at">data.seed =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>)</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="fu">head</span>(dataGrid)</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 × 4</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt;   fun     numTraj randomScales data.seed</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;     &lt;int&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">#&gt; 1 dataGen      50          0.1         1</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co">#&gt; 2 dataGen     250          0.1         1</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a><span class="co">#&gt; 3 dataGen      50          0.5         1</span></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co">#&gt; 4 dataGen     250          0.5         1</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="co">#&gt; 5 dataGen      50          0.1         2</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co">#&gt; 6 dataGen     250          0.1         2</span></span></code></pre></div>
</div>
<div id="method-settings" class="section level1">
<h1>Method settings</h1>
<p>Similarly to the data settings table, we specify a table of all
permutations for the method settings. Typically this is done separately
for each method, as their settings will usually differ. In this example
we evaluate KmL and GCKM only on differing number of clusters so the
method settings can be jointly generated. Repeated method evaluation is
achieved through specifying several values for the <code>seed</code>
argument.</p>
<p>The method evaluation function (specified by the <code>proc</code>
field) here is simply the <code>latrend()</code> function, which will
fit the specified method type to the generated data. ## Specfying the
KmL method</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>kmlMethodGrid <span class="ot">&lt;-</span> simTool<span class="sc">::</span><span class="fu">expand_tibble</span>(</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="at">proc =</span> <span class="st">&quot;latrend&quot;</span>,</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="at">method =</span> <span class="st">&quot;lcMethodKML&quot;</span>,</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="at">nClusters =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="at">seed =</span> <span class="dv">1</span>,</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  <span class="at">response =</span> <span class="st">&quot;Y&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="fu">head</span>(kmlMethodGrid)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt; # A tibble: 2 × 5</span></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="co">#&gt;   proc    method      nClusters  seed response</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   </span></span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a><span class="co">#&gt; 1 latrend lcMethodKML         1     1 Y       </span></span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a><span class="co">#&gt; 2 latrend lcMethodKML         2     1 Y</span></span></code></pre></div>
<div id="specifying-the-gckm-method" class="section level2">
<h2>Specifying the GCKM method</h2>
<p>Parametric models such as GCKM are more unwieldy to specify in a
simulation study due to the need to define the parametric shape through
one or more formulas. Formulas are tedious to query or filter in a
post-hoc simulation analysis<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>We can solve this by defining simple keywords representing the
different parametric shapes of interest. We then specify a wrapper
function for <code>latrend()</code> that sets the correct
<code>formula</code> argument depending on the keyword.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>fitGCKM <span class="ot">&lt;-</span> <span class="cf">function</span>(type, ...) {</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  form <span class="ot">&lt;-</span> <span class="cf">switch</span>(type,</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>    <span class="at">constant =</span> Y <span class="sc">~</span> Time <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> Traj),</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    <span class="at">linear =</span> Y <span class="sc">~</span> Time <span class="sc">+</span> (Time <span class="sc">|</span> Traj)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>  )</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  </span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  <span class="fu">latrend</span>(..., <span class="at">formula =</span> form)</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>}</span></code></pre></div>
<p>We can then specify our GCKM method settings in a similar way as we
did for the KmL method, but with the <code>proc</code> argument set to
the <code>fitGCKM</code> function we have just defined.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>gckmMethodGrid <span class="ot">&lt;-</span> simTool<span class="sc">::</span><span class="fu">expand_tibble</span>(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>  <span class="at">proc =</span> <span class="st">&quot;fitGCKM&quot;</span>,</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>  <span class="at">method =</span> <span class="st">&quot;lcMethodGCKM&quot;</span>,</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>  <span class="at">type =</span> <span class="fu">c</span>(<span class="st">&quot;constant&quot;</span>, <span class="st">&quot;linear&quot;</span>),</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>  <span class="at">nClusters =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  <span class="at">seed =</span> <span class="dv">1</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>)</span></code></pre></div>
<p>Finally, we combine our method-specific permutation grids into one
large grid. By using the <code>bind_rows()</code> function, mismatches
in the columns between the grids are handled properly.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>methodGrid <span class="ot">&lt;-</span> dplyr<span class="sc">::</span><span class="fu">bind_rows</span>(kmlMethodGrid, gckmMethodGrid)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="fu">head</span>(methodGrid)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 × 6</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#&gt;   proc    method       nClusters  seed response type    </span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;            &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;   </span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt; 1 latrend lcMethodKML          1     1 Y        &lt;NA&gt;    </span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; 2 latrend lcMethodKML          2     1 Y        &lt;NA&gt;    </span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; 3 fitGCKM lcMethodGCKM         1     1 &lt;NA&gt;     constant</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; 4 fitGCKM lcMethodGCKM         1     1 &lt;NA&gt;     linear  </span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; 5 fitGCKM lcMethodGCKM         2     1 &lt;NA&gt;     constant</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt; 6 fitGCKM lcMethodGCKM         2     1 &lt;NA&gt;     linear</span></span></code></pre></div>
</div>
</div>
<div id="evaluating-the-settings" class="section level1">
<h1>Evaluating the settings</h1>
<p>The <code>eval_tibbles()</code> function takes the data and method
grids as inputs, and runs the method estimation as intended for each
simulation setting. In practice, it is advisable to run evaluations in
parallel as the number of simulation settings is likely much greater
than in this trivial demonstration.</p>
<p>Before we run the simulations, we first want to define a function for
computing our model performance metrics. This function will be run by
<code>eval_tibbles()</code> for every estimated model. The details on
what we are computing here is explained further in the next section.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>analyzeModel <span class="ot">&lt;-</span> <span class="cf">function</span>(model) {</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">model.data</span>(model)</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  refModel <span class="ot">&lt;-</span> <span class="fu">lcModelPartition</span>(data, <span class="at">response =</span> <span class="st">&quot;Y&quot;</span>, <span class="at">trajectoryAssignments =</span> <span class="st">&quot;Class&quot;</span>)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>  </span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>  tibble<span class="sc">::</span><span class="fu">tibble</span>(</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>    <span class="at">BIC =</span> <span class="fu">BIC</span>(model),</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>    <span class="at">APPA =</span> <span class="fu">metric</span>(model, <span class="st">&quot;APPA.min&quot;</span>),</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>    <span class="at">WMAE =</span> <span class="fu">metric</span>(model, <span class="st">&quot;WMAE&quot;</span>),</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>    <span class="at">ARI =</span> <span class="fu">externalMetric</span>(model, refModel, <span class="st">&quot;adjustedRand&quot;</span>)</span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a>  )</span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a>}</span></code></pre></div>
<p>At last, we can run the simulations and post-hoc summary
computations:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>result <span class="ot">&lt;-</span> simTool<span class="sc">::</span><span class="fu">eval_tibbles</span>(</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="at">data_grid =</span> dataGrid, </span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="at">proc_grid =</span> methodGrid,</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="at">post_analyze =</span> analyzeModel</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>)</span></code></pre></div>
<p>The <code>result</code> table contains a <code>results</code> column
containing the fitted models.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>result</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 48 × 15</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">#&gt;    fun     numTraj randomScales data.seed replications proc    method  nClusters</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">#&gt;    &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;     &lt;int&gt;        &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;       &lt;int&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a><span class="co">#&gt;  1 dataGen      50          0.1         1            1 latrend lcMeth…         1</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co">#&gt;  2 dataGen      50          0.1         1            1 latrend lcMeth…         2</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="co">#&gt;  3 dataGen      50          0.1         1            1 fitGCKM lcMeth…         1</span></span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a><span class="co">#&gt;  4 dataGen      50          0.1         1            1 fitGCKM lcMeth…         1</span></span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a><span class="co">#&gt;  5 dataGen      50          0.1         1            1 fitGCKM lcMeth…         2</span></span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a><span class="co">#&gt;  6 dataGen      50          0.1         1            1 fitGCKM lcMeth…         2</span></span>
<span id="cb12-11"><a href="#cb12-11" tabindex="-1"></a><span class="co">#&gt;  7 dataGen     250          0.1         1            1 latrend lcMeth…         1</span></span>
<span id="cb12-12"><a href="#cb12-12" tabindex="-1"></a><span class="co">#&gt;  8 dataGen     250          0.1         1            1 latrend lcMeth…         2</span></span>
<span id="cb12-13"><a href="#cb12-13" tabindex="-1"></a><span class="co">#&gt;  9 dataGen     250          0.1         1            1 fitGCKM lcMeth…         1</span></span>
<span id="cb12-14"><a href="#cb12-14" tabindex="-1"></a><span class="co">#&gt; 10 dataGen     250          0.1         1            1 fitGCKM lcMeth…         1</span></span>
<span id="cb12-15"><a href="#cb12-15" tabindex="-1"></a><span class="co">#&gt; # ℹ 38 more rows</span></span>
<span id="cb12-16"><a href="#cb12-16" tabindex="-1"></a><span class="co">#&gt; # ℹ 7 more variables: seed &lt;dbl&gt;, response &lt;chr&gt;, type &lt;chr&gt;, BIC &lt;dbl&gt;,</span></span>
<span id="cb12-17"><a href="#cb12-17" tabindex="-1"></a><span class="co">#&gt; #   APPA &lt;dbl&gt;, WMAE &lt;dbl&gt;, ARI &lt;dbl&gt;</span></span>
<span id="cb12-18"><a href="#cb12-18" tabindex="-1"></a><span class="co">#&gt; Number of data generating functions: 8</span></span>
<span id="cb12-19"><a href="#cb12-19" tabindex="-1"></a><span class="co">#&gt; Number of analyzing procedures: 6</span></span>
<span id="cb12-20"><a href="#cb12-20" tabindex="-1"></a><span class="co">#&gt; Number of replications: 1</span></span>
<span id="cb12-21"><a href="#cb12-21" tabindex="-1"></a><span class="co">#&gt; Estimated replications per hour: 329</span></span>
<span id="cb12-22"><a href="#cb12-22" tabindex="-1"></a><span class="co">#&gt; Start of the simulation: 2025-07-04 15:55:54.490231</span></span>
<span id="cb12-23"><a href="#cb12-23" tabindex="-1"></a><span class="co">#&gt; End of the simulation: 2025-07-04 15:56:05.411735</span></span></code></pre></div>
</div>
<div id="analyzing-the-results" class="section level1">
<h1>Analyzing the results</h1>
<p>We can now analyze the computed results. We use the <a href="https://cran.r-project.org/package=data.table">data.table</a>
package to handle the filtering and aggregation of the results
table.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>resultsTable <span class="ot">&lt;-</span> <span class="fu">as.data.table</span>(result<span class="sc">$</span>simulation)</span></code></pre></div>
<div id="recovery-of-the-number-of-clusters" class="section level2">
<h2>Recovery of the number of clusters</h2>
<p>Often, researchers are interested in estimating the number of
clusters by means of minimizing a metric indicating either model fit,
cluster separation, or another factor that helps to determine the
preferred number of clusters. Evaluating how many times the correct
number of clusters is obtained from a cluster metric can help to decide
which metric to use, and which selection approach to take.</p>
<p>In this example, we evaluate the use of the Bayesian information
criterion (BIC). For each data scenario, we identify the cluster
solution that minimizes the BIC.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>resultsTable[, .(<span class="at">K =</span> nClusters[<span class="fu">which.min</span>(BIC)]), keyby <span class="ot">=</span> .(numTraj, randomScales, data.seed, method)]</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="co">#&gt; Key: &lt;numTraj, randomScales, data.seed, method&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="co">#&gt;     numTraj randomScales data.seed       method     K</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co">#&gt;       &lt;num&gt;        &lt;num&gt;     &lt;int&gt;       &lt;char&gt; &lt;int&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt;  1:      50          0.1         1 lcMethodGCKM     2</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co">#&gt;  2:      50          0.1         1  lcMethodKML     2</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co">#&gt;  3:      50          0.1         2 lcMethodGCKM     2</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co">#&gt;  4:      50          0.1         2  lcMethodKML     2</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a><span class="co">#&gt;  5:      50          0.5         1 lcMethodGCKM     2</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a><span class="co">#&gt;  6:      50          0.5         1  lcMethodKML     2</span></span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a><span class="co">#&gt;  7:      50          0.5         2 lcMethodGCKM     2</span></span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a><span class="co">#&gt;  8:      50          0.5         2  lcMethodKML     2</span></span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a><span class="co">#&gt;  9:     250          0.1         1 lcMethodGCKM     2</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a><span class="co">#&gt; 10:     250          0.1         1  lcMethodKML     2</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a><span class="co">#&gt; 11:     250          0.1         2 lcMethodGCKM     2</span></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a><span class="co">#&gt; 12:     250          0.1         2  lcMethodKML     2</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a><span class="co">#&gt; 13:     250          0.5         1 lcMethodGCKM     2</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a><span class="co">#&gt; 14:     250          0.5         1  lcMethodKML     2</span></span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a><span class="co">#&gt; 15:     250          0.5         2 lcMethodGCKM     2</span></span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a><span class="co">#&gt; 16:     250          0.5         2  lcMethodKML     2</span></span></code></pre></div>
<p>Column <em>K</em> of the table shows the selected number of clusters
for each scenario. This shows that estimating the number of clusters by
minimizing the BIC results in a consistent overestimation of the number
of clusters in our datasets. As an alternative to minimizing the BIC, we
could consider using the elbow method instead. However, in order to
conclude whether that is a feasible approach to our data would require
more simulations, across a greater number of cluster.</p>
</div>
<div id="trajectory-assignment-agreement" class="section level2">
<h2>Trajectory assignment agreement</h2>
<p>Another aspect of interest might be the ability of the cluster model
to identify the correct cluster assignment for each of the trajectories.
An intuitive metric for assessing this is the adjusted Rand index (ARI).
This metric measures the agreement between two partitionings, where a
score of 1 indicate a perfect agreement, and a score of 0 indicates an
agreement no better than by chance.</p>
<p>We compute the average ARI per data scenario and method to identify
in which scenarios the methods were able to recover the reference
cluster assignments.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>resultsTable[nClusters <span class="sc">&gt;</span> <span class="dv">1</span>, .(<span class="at">ARI =</span> <span class="fu">mean</span>(ARI)), keyby <span class="ot">=</span> .(nClusters, numTraj, randomScales, method)]</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="co">#&gt; Key: &lt;nClusters, numTraj, randomScales, method&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">#&gt;    nClusters numTraj randomScales       method       ARI</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#&gt;        &lt;int&gt;   &lt;num&gt;        &lt;num&gt;       &lt;char&gt;     &lt;num&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt; 1:         2      50          0.1 lcMethodGCKM 1.0000000</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a><span class="co">#&gt; 2:         2      50          0.1  lcMethodKML 1.0000000</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a><span class="co">#&gt; 3:         2      50          0.5 lcMethodGCKM 0.4740203</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a><span class="co">#&gt; 4:         2      50          0.5  lcMethodKML 0.1374062</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co">#&gt; 5:         2     250          0.1 lcMethodGCKM 0.9880822</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="co">#&gt; 6:         2     250          0.1  lcMethodKML 1.0000000</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a><span class="co">#&gt; 7:         2     250          0.5 lcMethodGCKM 0.4521689</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="co">#&gt; 8:         2     250          0.5  lcMethodKML 0.1323025</span></span></code></pre></div>
<p>The trajectory assignment recovery is affected the most by the
magnitude of the random scale (i.e., the amount of overlap between the
clusters). Moreover, it is apparent that KmL performs much worse under
high random scale than GCKM.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>resultsTable[nClusters <span class="sc">&gt;</span> <span class="dv">1</span>, .(<span class="at">ARI =</span> <span class="fu">mean</span>(ARI)), keyby <span class="ot">=</span> .(randomScales, nClusters, method)]</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="co">#&gt; Key: &lt;randomScales, nClusters, method&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">#&gt;    randomScales nClusters       method       ARI</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#&gt;           &lt;num&gt;     &lt;int&gt;       &lt;char&gt;     &lt;num&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="co">#&gt; 1:          0.1         2 lcMethodGCKM 0.9940411</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="co">#&gt; 2:          0.1         2  lcMethodKML 1.0000000</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="co">#&gt; 3:          0.5         2 lcMethodGCKM 0.4630946</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="co">#&gt; 4:          0.5         2  lcMethodKML 0.1348544</span></span></code></pre></div>
</div>
<div id="residual-error" class="section level2">
<h2>Residual error</h2>
<p>Another aspect of interest might be the residual error, i.e., how
well our cluster model describes the data. Here, we gauge this by
computing the mean absolute error, weighted by the posterior
probabilities<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<p>Both methods achieve practically the same mean residual error.
Another sign of the data comprising two clusters is that the MAE drops
down significantly for the two-cluster solution, but hardly any
improvement is gained for the three-cluster solution.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>resultsTable[randomScales <span class="sc">==</span> .<span class="dv">1</span>, .(<span class="at">WMAE =</span> <span class="fu">mean</span>(WMAE)), keyby <span class="ot">=</span> .(nClusters, method)]</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="co">#&gt; Key: &lt;nClusters, method&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="co">#&gt;    nClusters       method      WMAE</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="co">#&gt;        &lt;int&gt;       &lt;char&gt;     &lt;num&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="co">#&gt; 1:         1 lcMethodGCKM 0.2627083</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a><span class="co">#&gt; 2:         1  lcMethodKML 0.2627083</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a><span class="co">#&gt; 3:         2 lcMethodGCKM 0.1120481</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a><span class="co">#&gt; 4:         2  lcMethodKML 0.1119268</span></span></code></pre></div>
<p>As one would expect, the residual error is strongly affected by the
magnitude of the random scale.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>resultsTable[, .(<span class="at">WMAE =</span> <span class="fu">mean</span>(WMAE)), keyby <span class="ot">=</span> .(randomScales, nClusters)]</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="co">#&gt; Key: &lt;randomScales, nClusters&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="co">#&gt;    randomScales nClusters      WMAE</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="co">#&gt;           &lt;num&gt;     &lt;int&gt;     &lt;num&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="co">#&gt; 1:          0.1         1 0.2627083</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="co">#&gt; 2:          0.1         2 0.1120077</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="co">#&gt; 3:          0.5         1 0.4563443</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="co">#&gt; 4:          0.5         2 0.3257807</span></span></code></pre></div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>Another reason to avoid defining formulas directly in
the permutation grid is due to the way <code>data.frame</code> and
tibbles handle columns containing <code>formula</code>, returning a
<code>list</code> instead of the <code>formula</code> element when
querying a single row. This results in an invalid method specification
when <code>eval_tibbles()</code> calls the <code>proc</code> argument
using this output.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>For KmL and GCKM, the WMAE is effectively the same as
the MAE.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
